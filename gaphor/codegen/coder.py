"""The Coder.

The idea:
* Get all classes from a model
  * Drop all classes declared in a Profile
  * Drop all classes from a package blacklist
  * Drop all classes derived from SimpleAttribute's
  * Order all classes in hierarchical order
* Write class definitions
* Write attributes, derived unions, associations, redefines, etc.
  (not sure if there should be an order)

Notes:
* Enumerations are classes ending with "Kind"
* Two stereotypes: Tagged and SimpleAttribute
"""
from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Iterable

from gaphor import UML
from gaphor.codegen.override import Overrides
from gaphor.core.modeling import ElementFactory
from gaphor.storage import storage
from gaphor.UML.modelinglanguage import UMLModelingLanguage

from gaphor.core.modeling.properties import derived

header = """\
# This file is generated by coder.py. DO NOT EDIT!
# isort: skip_file
# flake8: noqa F401,F811
# fmt: off

from __future__ import annotations

from gaphor.core.modeling.properties import (
    association,
    attribute,
    derived,
    derivedunion,
    enumeration,
    redefine,
    relation_many,
    relation_one,
)

"""


def class_declaration(class_: UML.Class):
    base_classes = ", ".join(
        c.name for c in sorted(bases(class_), key=lambda c: c.name)  # type: ignore[no-any-return]
    )
    return f"class {class_.name}({base_classes}):"


def variables(class_: UML.Class, overrides: Overrides | None = None):
    if class_.ownedAttribute:
        for attr in sorted(class_.ownedAttribute, key=lambda a: a.name or ""):
            full_name = f"{class_.name}.{attr.name}"
            if overrides and overrides.has_override(full_name):
                yield f"{attr.name}: {overrides.get_type(full_name)}"
            elif attr.isDerived:
                pass
            elif attr.association and is_simple_attribute(attr.type):
                yield f'{attr.name}: attribute[str] = attribute("{attr.name}", str)'
            elif attr.association:
                mult = "one" if attr.upper == "1" else "many"
                yield f"{attr.name}: relation_{mult}[{attr.type.name}]"
            elif is_enumeration(attr.type):
                enum_values = ", ".join(f'"{e.name}"' for e in attr.type.ownedAttribute)
                yield f'{attr.name} = enumeration("{attr.name}", ({enum_values}), "{attr.type.ownedAttribute[0].name}")'
            else:
                if attr.defaultValue:
                    if attr.typeValue == "int":
                        defaultValue = attr.defaultValue.title()
                    elif attr.typeValue == "str":
                        defaultValue = f'"{attr.defaultValue}"'
                    else:
                        raise ValueError(
                            f"Unknown default value type: {class_.name}.{attr.name}: {attr.typeValue} = {attr.defaultValue}"
                        )

                    default = f", default={defaultValue}"
                else:
                    default = ""
                yield f'{attr.name}: attribute[{attr.typeValue}] = attribute("{attr.name}", {attr.typeValue}{default})'


def associations(c: UML.Class, overrides: Overrides | None = None):
    for a in c.ownedAttribute:
        full_name = f"{c.name}.{a.name}"
        if not a.association or is_simple_attribute(a.type):
            continue
        elif overrides and overrides.has_override(full_name):
            yield overrides.get_override(full_name)
        elif is_redefine(a):
            yield f"# redefine {full_name}"
        elif a.isDerived:
            yield f"# derivedunion {full_name}"
        else:
            lower = "" if a.lowerValue in (None, "0") else f", lower={a.lowerValue}"
            upper = "" if a.upperValue == "*" else f", upper=" f"{a.upperValue or 1}"
            composite = ", composite=True" if a.aggregation == "composite" else ""
            opposite = (
                f', opposite="{a.opposite.name}"'
                if a.opposite and a.opposite.name and a.opposite.class_
                else ""
            )

            yield f'{full_name} = association("{a.name}", {a.type.name}{lower}{upper}{composite}{opposite})'

        # <T>.<P>.subsets.add(<fullname>)


def order_classes(classes: Iterable[UML.Class]) -> Iterable[UML.Class]:
    seen_classes = set()

    def order(c):
        if c not in seen_classes:
            for b in bases(c):
                yield from order(b)
            yield c
            seen_classes.add(c)

    for c in classes:  # sorted(classes, key=lambda c: c.name):  # type: ignore
        yield from order(c)


def bases(c: UML.Class) -> Iterable[UML.Class]:
    for g in c.generalization:
        yield g.general
    # TODO: Add bases from extensions


def is_enumeration(c: UML.Class) -> bool:
    return c and c.name and (c.name.endswith("Kind") or c.name.endswith("Sort"))  # type: ignore[return-value]


def is_simple_attribute(c: UML.Class) -> bool:
    for s in UML.model.get_applied_stereotypes(c):
        if s.name == "SimpleAttribute":
            return True
    for g in c.generalization:
        if is_simple_attribute(g.general):
            return True
    return False


def is_in_profile(c: UML.Class) -> bool:
    def test(p: UML.Package):
        return isinstance(p, UML.Profile) or (p.owningPackage and test(p.owningPackage))

    return test(c.owningPackage)  # type: ignore[no-any-return]


def is_in_toplevel_package(c: UML.Class, package_name: str) -> bool:
    def test(p: UML.Package):
        return (not p.owningPackage and p.name == package_name) or (
            p.owningPackage and test(p.owningPackage)
        )

    return test(c.owningPackage)  # type: ignore[no-any-return]


def is_redefine(a: UML.Property) -> bool:
    return False


def last_minute_updates(element_factory: ElementFactory) -> None:
    """Some model updates that are hard to do from Gaphor itself."""
    for prop in element_factory.select(UML.Property):
        if prop.typeValue == "String":
            prop.typeValue = "str"
        elif prop.typeValue in ("Integer", "Boolean"):
            prop.typeValue = "int"
        else:
            c: UML.Class | None = next(
                element_factory.select(
                    lambda e: isinstance(e, UML.Class) and e.name == prop.typeValue
                ),  # type: ignore[arg-type]
                None,
            )
            if c:
                prop.type = c
                del prop.typeValue


def load_model(modelfile) -> ElementFactory:
    element_factory = ElementFactory()
    uml_modeling_language = UMLModelingLanguage()
    storage.load(
        modelfile,
        element_factory,
        uml_modeling_language,
    )

    last_minute_updates(element_factory)

    return element_factory


def coder(modelfile, overrides, outfile):

    element_factory = load_model(modelfile)
    classes = list(
        order_classes(
            c
            for c in element_factory.select(UML.Class)
            if not (is_enumeration(c) or is_simple_attribute(c) or is_in_profile(c))
        )
    )

    print(header, file=outfile)

    for c in classes:
        if overrides.has_override(c.name):
            print(overrides.get_override(c.name), file=outfile)
        else:
            print(class_declaration(c), file=outfile)
            properties = list(variables(c, overrides))
            if properties:
                for p in properties:
                    print(f"    {p}", file=outfile)
            else:
                print("    pass", file=outfile)
        print(file=outfile)
        print(file=outfile)

    for c in classes:
        for a in associations(c, overrides):
            print(a, file=outfile)
        # print(file=outfile)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("modelfile", type=Path, help="Gaphor model filename")
    parser.add_argument(
        "-o", dest="outfile", type=Path, help="Python data model filename"
    )
    parser.add_argument("-r", dest="overridesfile", type=Path, help="Override filename")
    args = parser.parse_args()

    overrides = Overrides(args.overridesfile)
    if args.outfile:
        with open(args.outfile, "w") as outfile:
            coder(args.modelfile, overrides, outfile)
    else:
        coder(args.modelfile, overrides, sys.stdout)
