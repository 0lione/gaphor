"""The Coder.

The idea:
* Get all classes from a model
  * Drop all classes declared in a Profile
  * Drop all classes from a package blacklist
  * Drop all classes derived from SimpleAttribute's
  * Order all classes in hierarchical order
* Write class definitions
* Write attributes, derived unions, associations, redefines, etc.
  (not sure if there should be an order)

Notes:
* Enumerations are classes ending with "Kind"
* Two stereotypes: Tagged and SimpleAttribute
"""
from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Iterable

from gaphor import UML
from gaphor.codegen.override import Overrides
from gaphor.core.modeling import ElementFactory
from gaphor.storage import storage
from gaphor.UML.modelinglanguage import UMLModelingLanguage

header = """\
# This file is generated by coder.py. DO NOT EDIT!
# isort: skip_file
# flake8: noqa F401,F811
# fmt: off

from __future__ import annotations

from gaphor.core.modeling.properties import (
    association,
    attribute,
    derived,
    derivedunion,
    enumeration,
    redefine,
    relation_many,
    relation_one,
)

"""


class Coder:
    def __init__(self, class_: UML.Class, overrides: Overrides | None = None):
        self._class = class_
        self.overrides = overrides

    def __str__(self):
        base_classes = ", ".join(
            c.name for c in sorted(bases(self._class), key=lambda c: c.name)  # type: ignore[no-any-return]
        )
        return f"class {self._class.name}({base_classes}):"

    def __iter__(self):
        if self._class.ownedAttribute:
            for attr in sorted(self._class.ownedAttribute, key=lambda a: a.name or ""):
                full_name = f"{self._class.name}.{attr.name}"
                if self.overrides and self.overrides.has_override(full_name):
                    yield f"{attr.name}: {self.overrides.get_type(full_name)}"
                elif attr.isDerived:
                    pass
                elif attr.association and is_simple_attribute(attr.type):
                    yield f'{attr.name}: attribute[str] = attribute("{attr.name}", str)'
                elif attr.association:
                    mult = "one" if attr.upper == "1" else "many"
                    yield f"{attr.name}: relation_{mult}[{attr.type.name}]"
                elif is_enumeration(attr.type):
                    enum_values = ", ".join(
                        f'"{e.name}"' for e in attr.type.ownedAttribute
                    )
                    yield f'{attr.name}: enumeration = enumeration("{attr.name}", ({enum_values}), "{attr.type.ownedAttribute[0].name}")'
                else:
                    if attr.defaultValue:
                        if attr.typeValue == "int":
                            defaultValue = attr.defaultValue.title()
                        elif attr.typeValue == "str":
                            defaultValue = f'"{attr.defaultValue}"'
                        else:
                            raise ValueError(
                                f"Unknown default value type: {self._class.name}.{attr.name}: {attr.typeValue} = {attr.defaultValue}"
                            )

                        default = f", default={defaultValue}"
                    else:
                        default = ""
                    yield f'{attr.name}: attribute[{attr.typeValue}] = attribute("{attr.name}", {attr.typeValue}{default})'


def order_classes(classes: Iterable[UML.Class]) -> Iterable[UML.Class]:
    seen_classes = set()

    def order(c):
        if c not in seen_classes:
            for b in bases(c):
                yield from order(b)
            yield c
            seen_classes.add(c)

    for c in classes:  # sorted(classes, key=lambda c: c.name):  # type: ignore
        yield from order(c)


def bases(c: UML.Class) -> Iterable[UML.Class]:
    for g in c.generalization:
        yield g.general
    # TODO: Add bases from extensions


def is_enumeration(c: UML.Class) -> bool:
    return bool(c and c.name and (c.name.endswith("Kind") or c.name.endswith("Sort")))


def is_simple_attribute(c: UML.Class) -> bool:
    for s in UML.model.get_applied_stereotypes(c):
        if s.name == "SimpleAttribute":
            return True
    for g in c.generalization:
        if is_simple_attribute(g.general):
            return True
    return False


def is_in_profile(c: UML.Class):
    def test(p: UML.Package):
        return isinstance(p, UML.Profile) or (p.owningPackage and test(p.owningPackage))

    return test(c.owningPackage)


def is_in_toplevel_package(c: UML.Class, package_name: str):
    def test(p: UML.Package):
        return (not p.owningPackage and p.name == package_name) or (
            p.owningPackage and test(p.owningPackage)
        )

    return test(c.owningPackage)


def last_minute_updates(element_factory: ElementFactory):
    """Some model updates that are hard to do from Gaphor itself."""
    for prop in element_factory.select(UML.Property):
        if prop.typeValue == "String":
            prop.typeValue = "str"
        elif prop.typeValue in ("Integer", "Boolean"):
            prop.typeValue = "int"
        else:
            c: UML.Class | None = next(
                element_factory.select(
                    lambda e: isinstance(e, UML.Class) and e.name == prop.typeValue
                ),  # type: ignore[arg-type]
                None,
            )
            if c:
                prop.type = c
                del prop.typeValue


def coder(modelfile, overrides, outfile):
    element_factory = ElementFactory()
    uml_modeling_language = UMLModelingLanguage()
    storage.load(
        modelfile,
        element_factory,
        uml_modeling_language,
    )

    last_minute_updates(element_factory)

    classes = list(
        order_classes(
            c
            for c in element_factory.select(UML.Class)
            if not (is_enumeration(c) or is_simple_attribute(c) or is_in_profile(c))
        )
    )

    print(header, file=outfile)

    for c in classes:
        if overrides.has_override(c.name):
            print(overrides.get_override(c.name), file=outfile)
        else:
            coder = Coder(c, overrides)
            print(coder, file=outfile)
            has_fields = False
            for a in coder:
                print("    " + a, file=outfile)
                has_fields = True
            if not has_fields:
                print("    pass", file=outfile)
        print(file=outfile)
        print(file=outfile)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("modelfile", type=Path, help="Gaphor model filename")
    parser.add_argument(
        "-o", dest="outfile", type=Path, help="Python data model filename"
    )
    parser.add_argument("-r", dest="overridesfile", type=Path, help="Override filename")
    args = parser.parse_args()

    overrides = Overrides(args.overridesfile)
    if args.outfile:
        with open(args.outfile, "w") as outfile:
            coder(args.modelfile, overrides, outfile)
    else:
        coder(args.modelfile, overrides, sys.stdout)
